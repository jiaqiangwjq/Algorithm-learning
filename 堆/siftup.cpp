/*
* 向上调整最小堆
* 只是向原堆中增加一个值
*/

void siftup(int i)      /* 传入一个需要向上调整的结点编号 i */
{
    int flag = 0;       /* 用来标记是否需要继续向上调整 */
    
    /* 如果是堆顶，就返回，不需要调整了 */
    if(i == 1)
        return;
    
    /* 不在堆顶, 并且当前结点 i 的值比父结点小的时候就继续向上调整 */
    while(i != 1 && flag == 0)
    {
        if(h[i] < h[i/2])
            swap(i, i/2);
        else
            flag = 1;       /* 表示已经不需要调整了，当前结点的值比父结点的值要大 */
        i /= 2;             /* 更新编号 i 为它父结点的值, 便于下一次继续向上调整 */
    }
}

void swap(int a, int b)
{
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
}