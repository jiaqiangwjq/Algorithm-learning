/*
* 向下调整最小堆
* 删除原堆中的最小值，然后再添加一个值
*/

/* 传入一个需要向下调整的结点编号 i */
void siftdown(int i)
{
    int t, flag = 0;    /* flag 用来标记是否需要继续向下调整 */

    /* 当结点 i 有儿子(至少有左儿子的情况下)并且有需要继续调整的时候，循环就执行 */
    while( i * 2 <= n && flag == 0 )
    {
        /* 首先判断它和左儿子的关系，并用 t 记录值较小的结点编号 */
        if( h[i] > h[i*2] )
            t = i * 2;
        else
            t = i;
        
        /* 如果它有右儿子，再对右儿子进行讨论 */
        if( i*2 + 1 <= n )
        {
            /* 如果右儿子的值更小，更新较小的结点编号 */
            if(h[t] > h[i*2 + 1])
                t = i * 2 + 1;
        }

        /* 如果发现最小的结点编号不是自己，说明子结点中有比父结点更小的 */
        if(t != i)
        {
            /* 交换它们 */
            swap(t, i);
            i = t;      /* 更新 i 为刚才与它交换的儿子结点的编号，便于接下来继续向下调整 */
        }
        else
        {
            /* 否则说明当前父结点已经比两个子结点都要小了，不需要再进行调整了 */
            flag = 1;
        }
    }
}

void swap(int a, int b)
{
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
}